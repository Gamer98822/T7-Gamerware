//=====================================================================================

#pragma once

#include "../Engine/Engine.hpp"

//=====================================================================================

#define msg_begin_read(msg) { auto over_flowed = msg.overflowed; auto read_count = msg.readcount;
#define msg_end_read(msg) msg.overflowed = over_flowed; msg.readcount = read_count; }

//=====================================================================================

namespace RCE
{
	void AddToLog(std::string output);


}

namespace t7
{
	class exploits_c
	{
	public:

		void package_invalid_statsbuffer(structures::LobbyMsg* lobby_msg);
		void package_invalid_voicedata(structures::LobbyMsg* lobby_msg);

		void send_modified_stats_crash(const std::int32_t clientnum);
		void send_modified_stats_crash(const std::uint64_t recipient, const structures::netadr_t& to);

		void send_voice_packet_crash(const std::int32_t clientnum);
		void send_voice_packet_crash(const std::uint64_t recipient, const structures::netadr_t& to);
		
		
		void SendZM_UI_ERROR(const std::uint64_t recipient, const structures::netadr_t& to);
		void Send_Client_Disconnect(const t7::structures::netadr_t& hostadr, uint64_t hostxuid, uint64_t victimxuid);
		void SendBADDLC(uint64_t XUID, const t7::structures::netadr_t& to);
		void send_voice_relay_packet_crash(const std::int32_t clientnum);
		void send_voice_relay_packet_crash(const std::uint64_t recipient, const structures::netadr_t& to);
		void SendNOPARTYCHAT3(uint64_t XUID, const t7::structures::netadr_t& to);
		void send_lsgame_crash(const t7::structures::netadr_t to, __int64 xuid);
		
		
		void send_instant_crash(const std::int32_t clientnum);
		void send_instant_crash(const std::vector<std::uint64_t>& recipients);

		void send_instant_popup(const std::int32_t clientnum);
		void send_instant_popup(const std::vector<std::uint64_t>& recipients);

		void send_relay_crash(const std::int32_t clientnum);
		void send_relay_crash(const structures::netadr_t& to);

		void send_vt_crash(const std::int32_t clientnum);
		void send_vt_crash(const structures::netadr_t& to);

		void send_all_crashes(const std::int32_t clientnum);
		void send_all_crashes(const std::uint64_t recipient, const structures::netadr_t& to);

		void send_migration_screen(const std::int32_t clientnum);
		void send_migration_screen(const structures::netadr_t& to);

		void send_immobilization_screen(const std::int32_t clientnum);
		void send_immobilization_screen(const structures::netadr_t& to);

		void send_migration_kick(const std::int32_t clientnum);
		void send_migration_kick(const structures::netadr_t& to);

		void send_disconnect_kick(const std::int32_t clientnum);
		void send_disconnect_kick(const std::uint64_t recipient);

		void send_all_kicks(const std::int32_t clientnum);
		void send_all_kicks(const std::uint64_t recipient, const structures::netadr_t& to);

		bool send_oob_data(const structures::netadr_t& to, const std::string& data, const structures::netsrc_t sock = structures::NS_SERVER);
		void Send_empty_OOB(const std::uint64_t recipient, const structures::netadr_t& to);
		
		inline void Spoof_Xuid(bool isSpoofed);


		void log_server_command();
		bool log_connectionless_packet(const structures::netadr_t& from, structures::msg_t* msg);
		bool log_instant_message(const char* message, const std::uint32_t message_size, const std::uint64_t from);
		bool log_package_element(structures::LobbyMsg* lobby_msg, const structures::LobbyMsgElementType type);

		bool inspect_host_disconnect(structures::LobbyMsg* lobby_msg);
		bool inspect_lobby_state(structures::LobbyMsg* lobby_msg);
		bool inspect_modified_stats(structures::LobbyMsg* lobby_msg);
		bool inspect_join_handshake(structures::LobbyMsg* lobby_msg);
		bool inspect_voice_packet(structures::LobbyMsg* lobby_msg);

		bool should_ignore_msg
		(
			const structures::netadr_t& from_adr,
			const std::uint64_t from_xuid,
			const structures::LobbyModule lobby_module,
			const structures::LobbyType lobby_type,
			structures::LobbyMsg* lobby_msg
		);

		bool log_packet_internal
		(
			const structures::netadr_t& from_adr, 
			const std::uint64_t from_xuid, 
			const structures::LobbyModule lobby_module, 
			const structures::LobbyType lobby_type, 
			structures::LobbyMsg* lobby_msg
		);
	};

	extern exploits_c exploits;
}

//=====================================================================================